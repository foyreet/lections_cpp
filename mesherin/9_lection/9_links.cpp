#include <iostream>
/*
int main() {

// Сложные объявления
int* a[10]; // массив из 10 указателей на int
int (*b)[10]; // указатель на массив из 10 int
void (*pf)(int)  // указатель на функцию, которая принимает int возвращает void
    void (*pfa[10])(int); // массив из 10 указателей которая возвращает int принимает void
    void (*(*pff[10])(int))(int); // массив из 10 указателей на функцию
    // которая принимает int и возвращает указатель на функцию которая принмает int возвращает void
    void (*(*) ()) (int); // указатель на функцию которая возвращает указатель на фунцию которая принимает int и возвращает void
*/
  /*
  //Ссылки(References)
  // Создание нового имени старого объекта, а не создание другого объекта для этого нужны ссылки
  std::string s = "ananan";
  std::string& s_new = s; // новое имя s_new у старого объекта s (у нас всего 1 объект)
  std::cout << s_new << std::endl;
  // string& - не уничтожается при выходе из области видимости, а string уничтожается при выходе из области видимости
  // Если мы напишем в с++ так
  std::string s1 = "ans";
  std::string s2 = s1;
  std::cout << s1 << std::endl;
  std::cout << s2 << std::endl;
  // То у нас создастся 2 разных объекта

  В с++ мы не можем делать как в Python где
   a = [1,2 3]
   b = a;
   b.append(3)
   и в этом случае в python будет всего лишь 1 объект

   Мы не можем так сделать в с++ как в Python, потому что если бы так можно было сделать в с++ то когда бы удалялся этот объект.
   Ведь если у объекта несколько имён и присваивание означает не создание нового объекта, а смену имени, то  как в Runtime понять
   этому объекту соответсвует какое - то имя или нет и нам для этого нужен сборщик мусора, а его в с++ нет

   В с++ проблема уничтожения объекта решена так:
   когда у нас выходит из области видимости тип string&, то с объектом ничего не происходит
   а когда у нас выходит из области видимости тип string, то объект уничтожается
   Это решается в Copmpile time когда у нас будет уничтожатся объект
   Поэтому нам не нужно ввести счётчик ссылок в Runtime. Потому что известно всё уже в Compile time

  int x = 5;
  int& y = x;
  int z = 8;
  y = z;
  std::cout << y << '\n'; // x = z
  std::cout << x << '\n'; // x = z
  // y - это и есть x. Они взаимозаменяемы
  std::cout << sizeof(y) << " " << "byte" << std::endl;
}
*/

/* Вот так выдастся ошибка
void f(int &y) {
  y++;
}

void f(int x) {
  x++;
}
 int main() {
   f(x);
   f(y);
}

*/
void swap (int& x, int& y) {
  int t = x;
  x = y;
  y = t;
}

int main() {

}
/*
 Ссылки нельзя оставлять без инициализации int& r; будет CE
 Ссылку нужно обязательно проинициализировать при создании. Ссылку нужно обязательно проинициализировать lvalue,а не rvalue

 int& x = ++x; // ++x - lvalue
 Возвращаемый тип ++x int&
 Возвращаемый тип *p int& // *p даёт новый способ доступа к тому что раньше уже было и как - то называлось

 int& g(int & x) {
  return ++x;
 }
  g(x) = 6;
  v[x] = 6;
  На самом деле в с++ [] - должны возвращать ссылку и тогда результату можно будет присваивать

 */
