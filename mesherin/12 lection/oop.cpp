/*
 Классы и структуры. Инкапсуляция
 Типы - классы
 данные в классах - поля
 операции над данными - методы
 переменные имеющие эти типы - объекты

 В структуре всё публичное по умолчанию, а в классе всё приватное по умолчанию

 */

#include <iostream>
struct S {
    int x;
    double y;
    int z;
    void fff(int x, int y);
    void f(int x, int y) {
        std::cout << x + y;
    }

    void ff(int x) {
        std::cout << this->x;
    }
    struct SS {
        char c;
    };

};
void S::fff(int x, int y) {
    std::cout << x - y;
}
int main() {
    S s{2,3,4}; // Агрегатная инициализация (public поля)
    S::SS b;
    std::cout << s.x << std::endl;
    std::cout << s.y << std::endl;
    std::cout << s.z << std::endl;
    std::cout << sizeof(S) << '\n';
    s.f(s.x, s.y);
    std::cout << '\n';
    s.fff(3,4);
    std::cout << '\n';
    s.ff(6);
}
/*
 Размер класса это сумма размеров его полей в точности до выравнивания
 int x;
 double y;
 16 байт (8 * 2)
 Чтобы обратиться к 8 байтному полю нужно сделать выравнивание до 8 байт. Кратность по наибольшему размеру типа в байтах.
 Например:
 int x;
 double y;
 sizeof(double) = 8. размер класса (в байтах) кратен 8

 В памяти поля класса лежат в том порядке как объявлены
 Внутри класса нельзя:
 1) Писать expression
 2) Объявлять namespace

 Можно объявлять внутри класса:
 1) переменные
 2) функции
 3) using с типами Например: using string = std::string;

 Можно пользоваться методами до того как они объявлены. Можно вызывать один метод из другого
 Например:
 void f(int x, int y) {
        std::cout << x + y;
        ff();
    }

    void ff() {

    }

К методу можно обращаться и не из класса если сделать объявление в классе

 Ключевое слово this:
 Из метода класса получить объект.this это указатель на объект
 (*this).x и this -> x это одно и тоже

 Внутри классов можно объвлять другие классы
 */
